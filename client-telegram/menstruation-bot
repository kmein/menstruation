#!/usr/bin/env python3
from datetime import date, datetime, timedelta
from telegram import ParseMode, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import CommandHandler, MessageHandler, CallbackQueryHandler
from telegram.ext import Updater
from telegram.ext.filters import Filters
from toolz import pipe
from toolz.curried import itemmap, filter, map
from typing import Callable, Tuple, Set, Dict
import configparser
from emoji import emojize, demojize
import json
import locale
import logging
import os
import random
import re
import requests
import sys

try:
    ENDPOINT = os.environ["MENSTRUATION_ENDPOINT"]
    if not ENDPOINT:
        raise KeyError
except KeyError:
    ENDPOINT = "http://127.0.0.1:80"

if "MENSTRUATION_DIR" not in os.environ:
    print(
        "Please specify configuration directory in variable MENSTRUATION_DIR.", file=sys.stderr
    )
    sys.exit(1)
CONFIGURATION_DIRECTORY = os.environ["MENSTRUATION_DIR"].strip()

CONFIGURATION_FILE = os.path.join(CONFIGURATION_DIRECTORY, "config.ini")

config = configparser.ConfigParser()
config.read(CONFIGURATION_FILE)

locale.setlocale(locale.LC_ALL, "de_DE.UTF-8")

logging.basicConfig(level=logging.DEBUG)

tag_emoji = {
    "vegetarian": ":carrot:",
    "vegan": ":seedling:",
    "organic": ":smiling_face_with_halo:",
    "sustainable fishing": ":fish:",
    "climate": ":globe_showing_Americas:",
    "yellow": ":yellow_heart:",
    "green": ":green_heart:",
    "red": ":red_heart:",
}

emoji_tag = itemmap(reversed)(tag_emoji)


def render_meal(meal):
    return "{color}{price} _{name}_ {tags}".format(
        color=tag_emoji[meal["color"]],
        price=r" \[{}]".format(locale.currency(meal["price"]["student"]))
        if "student" in meal["price"]
        else "",
        name=meal["name"],
        tags="".join(tag_emoji[tag] for tag in meal["tags"]),
    )


def filter_meals(max_price, colors, tags):
    def process(group):
        group["meals"] = pipe(
            group["meals"],
            filter(
                lambda meal: (
                    (not colors or meal["color"] in colors)
                    and (not tags or set(meal["tags"]) & tags)
                    and (
                        "student" not in meal["price"]
                        or meal["price"]["student"] <= max_price
                    )
                )
            ),
            list,
        )
        return group

    return process


def render_group(group):
    if group["meals"]:
        return "*{name}*\n{meals}\n\n".format(
            name=group["name"].upper(),
            meals="\n".join(map(render_meal)(group["meals"])),
        )
    else:
        return ""


def extract_query(text: str) -> Tuple[float, Set[str], Set[str]]:
    max_price_result = re.search(r"(\d+)\s?€", text)
    max_price = float(max_price_result.group(1) if max_price_result else "inf")

    colors = set(
        emoji_tag[emoji]
        for emoji in re.findall(r"(:green_heart:|:yellow_heart:|:red_heart:)", text)
    )
    tags = set(
        emoji_tag[emoji]
        for emoji in re.findall(
            r"(:carrot:|:seedling:|:smiling_face_with_halo:|:fish:|:globe_showing_Americas:)",
            text,
        )
    )

    logging.info('Extracted {} from "{}"'.format((max_price, colors, tags), text))
    return max_price, colors, tags


def extract_date(text: str) -> date:
    matches = re.search(r"(\d{4}-\d{2}-\d{2}|today|tomorrow)", text)
    if matches:
        if matches.group(1) == "today":
            parsed_date = date.today()
        elif matches.group(1) == "tomorrow":
            parsed_date = date.today() + timedelta(days=1)
        elif matches.group(1):
            parsed_date = datetime.strptime(matches.group(1), "%Y-%m-%d").date()
        else:
            parsed_date = date.today()
            logging.info("Malformed date in '{}', defaulting to today".format(text))
        logging.info('Extracted {} from "{}"'.format(parsed_date, text))
        return parsed_date


def get_json(mensa_code: int, date: date) -> dict:
    request_url = "{}/{}/{}".format(ENDPOINT, mensa_code, date)
    logging.info("Requesting {}".format(request_url))
    return json.loads(requests.get(request_url).text)


def get_mensas() -> Dict[str, str]:
    request_url = "{}/codes".format(ENDPOINT)
    logging.info("Requesting {}".format(request_url))
    json_object = json.loads(requests.get(request_url).text)
    code_address = dict()
    for uni in json_object["unis"]:
        for mensa in uni["mensas"]:
            if "Coffeebar" not in mensa["address"]:
                code_address[mensa["code"]] = mensa["address"].split(" / ")[0]
    return code_address


def help_handler(bot, update):
    def infos(mapping):
        return "\n".join(k + " – " + v for k, v in mapping.items())

    command_description = {
        "/menu :seedling: 3€": "Heutige Speiseangebote (vegan bis 3€).",
        "/menu tomorrow": "Morgige Speiseangebote.",
        "/menu 2018-10-22": "Speiseangebote für den 22.10.2018.",
        "/help": "Dieser Hilfetext.",
        "/mensa beuth": "Auswahlmenü für die Mensen der Beuth Hochschule.",
    }
    emoji_description = {
        ":carrot:": "vegetarisch",
        ":seedling:": "vegan",
        ":smiling_face_with_halo:": "Bio",
        ":fish:": "nachhaltig gefischt",
        ":globe_showing_Americas:": "klimafreundlich",
        ":yellow_heart:": "Lebensmittelampel gelb",
        ":green_heart:": "Lebensmittelampel grün",
        ":red_heart:": "Lebensmittelampel rot",
    }
    bot.send_message(
        update.message.chat_id,
        emojize(
            "*BEFEHLE*\n{}\n\n*LEGENDE*\n{}".format(
                infos(command_description), infos(emoji_description)
            )
        ),
        parse_mode=ParseMode.MARKDOWN,
    )


def menstrudate_handler(bot, update, args):
    text = demojize("".join(args))
    max_price, colors, tags = extract_query(text)
    try:
        menstru_date = extract_date(text)
    except ValueError as e:
        logging.warning(e)
        bot.send_message(
            update.message.chat_id,
            emojize(
                "Du hast das Datum falsch angegeben. {}\nNutze dafür bitte `JJJJ-MM-TT`.".format(
                    error_emoji()
                )
            ),
            parse_mode=ParseMode.MARKDOWN,
        )
        return

    try:
        json_object = get_json(
            config.get(str(update.message.from_user.id), "mensa"), menstru_date
        )
    except configparser.NoSectionError as e:
        logging.warning(e)
        bot.send_message(
            update.message.chat_id,
            emojize(
                "Wie es aussieht, hast Du noch keine Mensa ausgewählt. {}\nTu dies zum Beispiel mit „/mensa adlershof“ :index_pointing_up:".format(
                    error_emoji()
                )
            ),
        )
        return
    except ValueError as e:
        logging.warning(e)
        bot.send_message(
            update.message.chat_id,
            emojize(
                "Entweder ist diese Mensa noch nicht unterstützt, {}\noder es gibt an diesem dort Tag kein Essen. {}".format(
                    error_emoji(), error_emoji()
                )
            ),
        )
        return

    reply = "".join(
        pipe(
            json_object["groups"],
            map(filter_meals(max_price, colors, tags)),
            map(render_group),
        )
    )
    if reply:
        bot.send_message(
            update.message.chat_id, emojize(reply), parse_mode=ParseMode.MARKDOWN
        )
    else:
        bot.send_message(
            update.message.chat_id,
            emojize("Kein Essen gefunden. {}".format(error_emoji())),
        )


def mensa_handler(bot, update, args):
    text = " ".join(args)
    code_address = get_mensas()
    pattern = text.strip()
    mensa_chooser = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=address, callback_data=code)]
            for code, address in sorted(code_address.items(), key=lambda item: item[1])
            if pattern.lower() in address.lower()
        ]
    )
    bot.send_message(
        update.message.chat_id,
        emojize("Wähle Deine Mensa aus. :ballot_box_with_check:"),
        reply_markup=mensa_chooser,
    )


def mensa_callback_handler(bot, update):
    query = update.callback_query
    if query:
        section = str(query.from_user.id)
        if not config.has_section(section):
            config.add_section(section)
            logging.info("Created new config section: {}".format(section))
        address = get_mensas()[query.data]
        bot.answer_callback_query(
            query.id,
            text=emojize("Mensa „{}“ ausgewählt. :flexed_biceps:".format(address)),
        )
        config.set(section, "mensa", query.data)
        logging.info("Set {}.mensa to {}".format(section, query.data))


def error_emoji():
    return random.choice(
        [
            ":confused_face:",
            ":worried_face:",
            ":slightly_frowning_face:",
            ":frowning_face:",
            ":face_with_open_mouth:",
            ":hushed_face:",
            ":astonished_face:",
            ":flushed_face:",
            ":pleading_face:",
            ":frowning_face_with_open_mouth:",
            ":anguished_face:",
            ":fearful_face:",
            ":anxious_face_with_sweat:",
            ":sad_but_relieved_face:",
            ":crying_face:",
            ":loudly_crying_face:",
            ":face_screaming_in_fear:",
            ":confounded_face:",
            ":persevering_face:",
            ":disappointed_face:",
            ":downcast_face_with_sweat:",
            ":weary_face:",
            ":tired_face:",
        ]
    )


if __name__ == "__main__":
    if "MENSTRUATION_TOKEN" not in os.environ:
        print(
            "Please specify bot token in variable MENSTRUATION_TOKEN.", file=sys.stderr
        )
        sys.exit(1)
    TOKEN = os.environ["MENSTRUATION_TOKEN"].strip()

    bot = Updater(token=TOKEN)
    bot.dispatcher.add_handler(CommandHandler("help", help_handler))
    bot.dispatcher.add_handler(CommandHandler("start", help_handler))
    bot.dispatcher.add_handler(
        CommandHandler("menu", menstrudate_handler, pass_args=True)
    )
    bot.dispatcher.add_handler(CommandHandler("mensa", mensa_handler, pass_args=True))
    bot.dispatcher.add_handler(CallbackQueryHandler(mensa_callback_handler))
    bot.dispatcher.add_handler(
        MessageHandler(
            Filters.command,
            lambda bot, update: bot.send_message(
                chat_id=update.message.chat_id, text="Hä?!"
            ),
        )
    )
    try:
        bot.start_polling()
    finally:
        with open(CONFIGURATION_FILE, "w") as ini:
            config.write(ini)
