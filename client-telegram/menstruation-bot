#!/usr/bin/env python3
from datetime import date, datetime, timedelta
from toolz import pipe
from toolz.curried import itemmap, filter, map
import emoji
import json
import locale
import logging
import os
import re
import requests
import sys
import telepot

try:
    ENDPOINT = os.environ["MENSTRUATION_ENDPOINT"]
    if not ENDPOINT:
        raise KeyError
except KeyError:
    ENDPOINT = "http://127.0.0.1:80"


locale.setlocale(locale.LC_ALL, 'de_DE.UTF-8')

logging.basicConfig(
    format="[%(levelname)s %(asctime)s] %(message)s",
    level=logging.INFO
)

tag_emoji = {
    "vegetarian": ":carrot:",
    "vegan": ":seedling:",
    "organic": ":smiling_face_with_halo:",
    "sustainable fishing": ":fish:",
    "climate": ":globe_showing_Americas:",
    "yellow": ":yellow_heart:",
    "green": ":green_heart:",
    "red": ":red_heart:",
}

emoji_tag = itemmap(reversed)(tag_emoji)


def render_meal(meal):
    return r"{color} \[{price}] _{name}_ {tags}".format(
        color=tag_emoji[meal["color"]],
        price=locale.currency(meal["price"]["student"]),
        name=meal["name"],
        tags="".join(tag_emoji[tag] for tag in meal["tags"]))


def filter_meals(max_price, colors, tags):
    def process(group):
        group["meals"] = pipe(
            group["meals"],
            filter(lambda meal: ((not colors or meal["color"] in colors)
                                 and (not tags or set(meal["tags"]) & tags)
                                 and (meal["price"]["student"] <= max_price))),
            list)
        return group
    return process


def render_group(group):
    if group["meals"]:
        return "*{name}*\n{meals}\n\n".format(
            name=group["name"].upper(),
            meals="\n".join(map(render_meal)(group["meals"]))
        )
    else:
        return ""


def handle(msg):
    def handle_menstruate(chat_id, text, date):
        logging.info("Getting menu for " + str(date))
        max_price_result = re.search(r"(\d+)\s?€", text)
        max_price = float(max_price_result.group(1) if max_price_result else "inf")

        colors = set(emoji_tag[emoji] for emoji in re.findall(
            r"(:green_heart:|:yellow_heart:|:red_heart:)", text
        ))
        tags = set(emoji_tag[emoji] for emoji in re.findall(
            r"(:carrot:|:seedling:|:smiling_face_with_halo:|:fish:|:globe_showing_Americas:)", text
        ))

        logging.info("Filtering {}, {} and {}.".format(max_price, colors, tags))

        try:
            request_url = ENDPOINT + "/{}/{}".format(191, date)
            logging.info("Requesting " + request_url)
            json_object = json.loads(requests.get(request_url).text)

            reply = emoji.emojize("".join(pipe(
                json_object["groups"],
                map(filter_meals(max_price, colors, tags)),
                map(render_group))))

            if not reply:
                raise ValueError("Filter criteria too specific.")

            bot.sendMessage(chat_id, reply, parse_mode='Markdown')
            logging.info("Sent menu plan.")
        except (ValueError, json.JSONDecodeError, requests.exceptions.ConnectionError) as e:
            bot.sendMessage(chat_id, emoji.emojize("Kein Essen gefunden. :worried_face:"))
            logging.warning("Sent error message: " + str(e))

    content_type, _, chat_id = telepot.glance(msg)
    if content_type == "text":
        if msg["text"].startswith("/help") or msg["text"].startswith("/start"):
            logging.info("Received /help or /start.")
            infos = lambda mapping: "\n".join(k + " – " + v for k, v in mapping.items())
            command_description = {
                "/menstruate :seedling: 3€": "Zeigt heutige Speiseangebote (vegan) bis 3€.",
                "/menstrudate tomorrow": "Zeigt morgige Speiseangebote.",
                "/menstrudate 2018-10-22": "Zeigt die Speiseangebote für den 22.10.2018."
            }
            bot.sendMessage(
                chat_id,
                emoji.emojize("*BEFEHLE*\n{}\n\n*LEGENDE*\n{}".format(
                    infos(command_description),
                    infos(emoji_tag))),
                parse_mode="Markdown"
            )
            logging.info("Sent help message.")
        elif msg["text"].startswith("/menstruate"):
            logging.info("Received /menstruate.")
            text = emoji.demojize(msg["text"])
            handle_menstruate(chat_id, text, date.today())
        elif msg["text"].startswith("/menstrudate"):
            logging.info("Received /menstrudate.")
            text = emoji.demojize(msg["text"])
            menstru_date = re.search(r"(\d{4}-\d{2}-\d{2}|tomorrow)", text)
            try:
                if menstru_date:
                    handle_menstruate(
                        chat_id,
                        text,
                        (date.today() + timedelta(days=1)
                         if menstru_date.group(1) == "tomorrow"
                         else datetime.strptime(menstru_date.group(1), "%Y-%m-%d").date())
                    )
                else:
                    raise ValueError()
            except ValueError:
                logging.warning("Malformed /menstrudate command: " + text)
                bot.sendMessage(chat_id, emoji.emojize("Falsches Datumsformat. :worried_face:\nBitte verwende JJJJ-MM-TT."))


if __name__ == "__main__":
    if "MENSTRUATION_TOKEN" not in os.environ:
        print("Please specify bot token in variable MENSTRUATION_TOKEN.", file=sys.stderr)
        sys.exit(1)
    TOKEN = os.environ["MENSTRUATION_TOKEN"].strip()
    bot = telepot.Bot(TOKEN)
    bot.message_loop(handle, run_forever=True)
